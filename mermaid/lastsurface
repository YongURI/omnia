#! /bin/zsh
# Usage: lastsurface
#
# Print date of MERMAIDs' last surfacing as recorded in the *.vit files.
#
# Author: Dr. Joel D. Simon
# Contact: jdsimon@alumni.princeton.edu | joeldsimon@gmail.com
# Last modified: 04-Sep-2020, Darwin Kernel Version 18.7.0

# Print help doc.
if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    sed -ne '/^#/!q;s/^#$/# /;/^# /s/^# //p' < "$0" |
	awk -v f="${1#-h}" '!f && /^Usage:/ || u { u=!/^\s*$/; if (!u) exit } u || f'
    exit 1
fi

# Set time zone local to JDS.
export TZ="America/Los_Angeles"

# Get current Unix Epoch time (-u is redundant, but left here).
current_epoch=$(date -u +%s)

# Specify output format.
output_fmt="%d-%b-%Y (%a @ %H:%M:%S %Z)"
computer=$(uname -s)

# Loop over all .vit files in the server.
for vit_file in $MERMAID/server/*.vit; do
    # Parse the float name from the vital file name.
    float_name=$(basename $vit_file)
    float_name=$(cut -c9-12 <<< $float_name)
    float_name=$(sed 's/-/0/' <<< $float_name)

    # The vital file usually ends with empty newline(s). Loop backwards until
    # you reach a line that includes text.
    idx=1
    line=$(tail -$idx $vit_file)
    while [ -z $line ]; do
	((idx++)) # ((X)) is for arithmetic evaluation
	line=$(tail -$idx $vit_file)

    done

    # Parse the UTC time of the last surfacing from the last non-empty line of
    # the .vit file.
    vit_time=$(cut -c1-18 <<< $line)

    # Parse date specifiers (year, month, day etc.) from UTC time.
    Y=$(cut -c1-4 <<< $vit_time)
    m=$(cut -c5-6 <<< $vit_time)
    d=$(cut -c7-8 <<< $vit_time)
    H=$(cut -c10-11 <<< $vit_time)
    M=$(cut -c13-14 <<< $vit_time)
    S=$(cut -c17-18 <<< $vit_time)

    # Convert vit time into ISO 8601 format date string.
    date_string="$Y-$m-${d}T$H:$M:${S}Z"
    input_fmt="%Y-%m-%dT%H:%M:%SZ"

    # Log the Unix Epoch time of the date string.
    if [ $computer = Darwin ]; then
	last_surface_epoch=$(date -ujf $input_fmt $date_string +%s) # UTC

    elif [ $computer = Linux ]; then
	last_surface_epoch=$(date -ud $date_string +%s) # UTC

    else
	echo "Error: $0 only tested on Linux and Mac computers"
	exit 1

    fi

    # Compute the number of days elapsed since the last transmission.
    # WARNING: ignores leap seconds.
    day_diff=$(bc <<< "scale=2; ($current_epoch - $last_surface_epoch) / (60*60*24)")
    day_diff=$(printf '%6.2f\n' $day_diff) # left pad with spaces

    # Print the output.
    if [ $computer = Darwin ]; then
	# In the OSX "date" command you may specify both an input and output
	# date format.  Use %z in the input format and append +0000 to the date
	# string to properly handle the timezone conversion from UTC.
	date -jf $input_fmt%z $date_string+0000 +"$float_name: $output_fmt --> $day_diff days ago"

    elif [ $computer = Linux ]; then
	# Cannot(?) specify and input format in POSIX "date" command.  However,
	# by default it does recognize the ISO 8601 format and properly handles
	# the timezone conversion from UTC under the hood.
	date -d $date_string +"$float_name: $output_fmt --> $day_diff days ago"

    fi
done
