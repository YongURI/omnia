function f = plot2normlystest(trusigmas, axlim, npts, lx, bp, ntests)
% f = PLOT2NORMLYSTEST(trusigmas,axlim,npts,lx,bp,ntests)
%
% Plots the outcome of two normlystest.m results, as well as one
% random signal which is generated by the distributions in that test,
% and finally plots the summed log-likelihood function of those two
% normlys plots, at the same normalized variances.  Will likely want
% to adjust some handles to text (f.f2.th, f.f3.th) and crosshairs
% (f.f1.xhairhg). No formatting (shifting and sizing of text boxes,
% for example) is done. Will require cleanup to make pretty.
%
% Inputs:
% trusigmas   Vector of 2 true sigmas to estimate (def: [1 sqrt(2)])
% axlim       x-axis limits of likelihood plots,
%                 called 'normvars' in normlystest.m (def: [.5 1.5])
% npts        Number of x-axis points (e.g., number of likelihood
%                 calculations per time series tested) (def: 100)
% lx          Length of random time series generated (def: 1000)
% bp          Changepoint of random signal generated (def: 500)
% ntests      Number of likelihood curves plotted (def: 100)
%
% Output:
% f           Struct with relevant figure handles
%
% Ex: 
%    f = PLOT2NORMLYSTEST([1 sqrt(2)], [0.5 1.5], 100, 1000, 500, 25)
%
% Citation: ??
% 
% See also: plotnormlystest.m, normlystest.m, suggestsigmas.m
%
% Last modified in Ver. 2017b by jdsimon@princeton.edu, 6-Feb-2018.

% Defaults.
defval('trusigmas', [1 sqrt(2)])
defval('axlim', [.5 1.5])
defval('npts', 100)
defval('lx', 1000)
defval('bp', 500)
defval('ntests', 100)

% Set up figure window.
f.f = figure;
fig2print(f.f, 'flandscape')
f.ha(1) = subplot(2,3,1);
f.ha(2) = subplot(2,3,2);
f.ha(3) = subplot(2,3,3);
f.ha(4) = subplot(2,3,4);
f.ha(4).Visible = 'off';
f.ha(5) = subplot(2, 3, [5 6]);

% Shift stuff around.
shrink(f.ha(5), 1, 1.5)
shrink(f.ha(4), 1, 1.5)
moveh(f.ha(2), .025)
moveh(f.ha(3), -.025)
movev(f.ha(4), .08)
movev(f.ha(5), .08)

% Align double-panel edges with subplots above.
l_edge = f.ha(2).Position(1);
r_edge = f.ha(3).Position(1) + f.ha(3).Position(3);
width = r_edge - l_edge;
f.ha(5).Position(1) = l_edge;
f.ha(5).Position(3) = width;

% Start plotting 
% Length of noise and signal.
lnk = length(1:bp);
lsk = length(bp+1:lx);

%_________________________________________________________________%
% Second plot: first normlystest.m, the noise, n(k).
ax = f.ha(2);
[lys2, ~ , f.f2] = normlystest(trusigmas(1), axlim, npts, lnk, ntests, ...
                               true, false, ax);
set(f.f2.ly, 'Color', 'b')
set(f.f2.MLE,'Color', 'k', 'MarkerFaceColor', 'k')

xlabel(ax, 'variance $\sigma_1^2/\sigma_{1\circ}^2$', 'Interpreter', ...
       'Latex');
ylabel(ax, 'log-likelihoods $\ell_1,~\ell_2$', 'Interpreter', 'Latex');

f.f2.hl = fx(horzline(f.f2.meany, ax, 'k'), 1);

%_________________________________________________________________%
% Third plot: second normlystest.m, the signal, s(k).
ax = f.ha(3);
[lys3, ~, f.f3] = normlystest(trusigmas(2), axlim, npts, lsk, ntests, ...
                              true, false, ax);

set(f.f3.ly, 'Color', 'r')
set(f.f3.MLE, 'Color', 'k', 'MarkerFaceColor', 'k')

xlabel(ax, 'variance $\sigma_2^2/\sigma_{2\circ}^2$', ...
       'Interpreter', 'Latex');


ylabel(ax, []);
yticklabels(ax, []);

f.f3.hl = fx(horzline(f.f3.meany, ax, 'k'), 1);

%_________________________________________________________________%
% Sum the likelihood values from both tests.  The XLim from both
% plots is the same; use one to generated XLim here.
ax = f.ha(1);
xl = f.f2.ly(1).XData;
hold(ax,'on')
grid(ax,'on')
grid(ax,'minor')

for i = 1:ntests
    % The summed likelihood curve.
    summed = lys2.curve{i} + lys3.curve{i};
    f.f1.ly(i) = plot(ax, xl, summed, 'm');

    % And the MLE value at that normalized sigma^2 found in testing.
    [lysval, idx] = max(summed);
    f.f1.MLEnormsigma2(i) = xl(idx);
    f.f1.MLE(i) = plot(ax, f.f1.MLEnormsigma2(i), lysval, 'ko', ...
                       'MarkerFaceColor','k');
end
hold(ax,'off')
box(ax,'on')

% Statistics -- using biased estimates in keeping with simon+2019.
f.f1.meanx = mean([f.f1.MLE.XData]);
f.f1.stdx = std([f.f1.MLE.XData], 1);
f.f1.varx = var([f.f1.MLE.XData], 1);

f.f1.meany = mean([f.f1.MLE.YData]);
f.f1.stdy = std([f.f1.MLE.YData], 1);
f.f1.vary = var([f.f1.MLE.YData], 1);

% Add a crosshair.
[f.f1.xhair,f.f1.xhairhg] = crosshair(ax, f.f1.meanx, f.f1.meany, 2*f.f1.stdx, 2*f.f1.stdy);

% Add a text box.
meanstr = sprintf(['mean($\\hat{\\sigma}^2/\\sigma_{\\circ}^2$) = ' ...
                   '%.3f'], f.f1.meanx);
varstr = sprintf(['~~~var($\\hat{\\sigma}^2/\\sigma_{\\circ}^2$) = ' ...
                  '%.3f'], f.f1.varx);
[f.f1.bh,f.f1.th] = boxtex('lm', ax, sprintf('%s\n%s', meanstr, varstr));
f.f1.th.Interpreter = 'latex';

% Set equal markersize on first plot.
set(f.f1.MLE, 'MarkerSize', f.f2.MLE(1).MarkerSize)

% Bring MLE markers above line; stack crosshair center above that.
set(f.f1.MLE, 'ZData', f.f1.xhair.c.ZData);
set(f.f1.xhair.c, 'ZData', f.f1.MLE(1).ZData+1);

xlabel(ax, 'variance $\sigma^2/\sigma_{\circ}^2$', 'Interpreter', ...
       'Latex');
ylabel(ax, 'summed log-likelihood $\ell$', 'Interpreter', 'Latex')

f.f1.hl = fx(horzline(f.f1.meany, ax, 'k'), 1);

%_________________________________________________________________%
% Fourth plot: the info string that sits where f.ha(4) would be.
ax = f.ha(4);
tstr = sprintf('Shown are %i tests:', ntests);
kstr = sprintf('$k = 1,...,1000,~k_{\\circ} = %i$,', bp);
nstr = sprintf(['$n(k)\\sim\\mathcal{N}(\\mu_{1}=0,\\sigma_{1\\' ...
                'circ}^2=%.2f$),'], trusigmas(1)^2);
sstr = sprintf(['$s(k)\\sim\\mathcal{N}(\\mu_{2}=0,\\sigma_{2\\' ...
                'circ}^2=%.2f),$'], trusigmas(2)^2);
xstr = sprintf('$x(k) = n(k) + s(k).$');
f.f4.th = text(ax, 0, 1, sprintf('%s\n%s\n%s\n%s\n%s', tstr, kstr, ...
                                 nstr, sstr, xstr), 'Interpreter', 'Latex');

%_________________________________________________________________%
% Fifth Plot: the time series.
% Generate time series that has same true distributions.
x = cpgen(lx, bp, 'norm', {0 trusigmas(1)}, 'norm', {0 trusigmas(2)});

% Plot synthetic time series.
ax = f.ha(5);
hold(ax, 'on')
f.f5.plL = plot(ax, [1:bp], x(1:bp), 'b');
f.f5.plR = plot(ax, [bp+1:lx], x(bp+1:end), 'r');
hold(ax, 'off')

% Annotate and label.
f.f5.vl = fx(vertline(bp, f.ha(5), 'k'));
xlabel(ax, 'sample index $k$', 'Interpreter', 'Latex');
ylabel(ax, '$x$', 'Interpreter', 'Latex');
box(ax, 'on');
xlim(ax, [1 lx])
add1XTick(ax);
symaxes(ax, 'y');
longticks(ax,4);

% End plotting: The rest is cosmetics.
%_________________________________________________________________%
% Link the axes; update the subplot 1 x-axis and others will
% automatically update.
linkaxes(f.ha(1:3));
f.ha(1).XLim = axlim;
set(f.ha, 'TickDir', 'out')
latimes(f.f)
orderfields(f);
